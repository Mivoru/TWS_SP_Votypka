<!DOCTYPE html>
<html lang="cs">
<head>
    <meta name="description" content="Implementace modelu TRM 2D pro simulaci transportn√≠ch a chemick√Ωch proces≈Ø v podzemn√≠ vodƒõ. P≈ôehled metod, algoritm≈Ø a optimalizac√≠ pou≈æit√Ωch v simulac√≠ch.">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementace TRM 2D</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
</head>
<body>
    <header>
        <h1>Implementace TRM 2D</h1>
        <div class="settings-container">
            <div id="settingsIcon"></div> 
            <div class="settings-buttons hidden">
                <button id="dark-mode-toggle">Tmav√Ω re≈æim</button>
                <button id="alt-mode-toggle">Alternativn√≠ re≈æim</button>
            </div>
        </div>
        <button class="menu-toggle">‚ò∞</button>
        <nav>
            <ul>
                <li><a href="index.html">√övod</a></li>
                <li><a href="transport.html">Transportn√≠ model</a></li>
                <li><a href="reaction.html">Reakƒçn√≠ model</a></li>
                <li><a href="contact.html">Kontakt</a></li>
                <li><a href="methods.html">Metody</a></li>
            </ul>
        </nav>
    </header>
    

    <main>
        <section id="implementation">
            <h2>P≈ôehled implementace</h2>
            <p>TRM 2D je implementov√°n jako konzolov√° aplikace, kter√° vyu≈æ√≠v√°:</p>
            <ul>
                <li>Metodu koneƒçn√Ωch diferenc√≠ (FDM) pro transport.</li>
                <li>Metodu koneƒçn√Ωch objem≈Ø (FVM) pro reakce.</li>
                <li>Automatick√© ≈ô√≠zen√≠ ƒçasov√©ho kroku pro zaji≈°tƒõn√≠ stability v√Ωpoƒçt≈Ø.</li>
            </ul>
        </section>

        <section id="method-list">
            <h2>P≈ô√≠klady metod a jejich vysvƒõtlen√≠</h2>
        
            <!-- TRM -->
            <div class="method-group">
                <button class="group-toggle" onclick="toggleGroup('trm')">üìÇ trm.cpp</button>
                <div class="method-group-details" id="trm">
            <div class="method" id="init_quantities">
                <button class="method-toggle">‚ûï init_quantities()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>
                                Tato metoda inicializuje seznam veliƒçin a jejich jednotek na z√°kladƒõ XML souboru.
                        Proch√°z√≠ XML stromem a hled√° uzly s atributem quantityID. Pokud je atribut nalezen,
                        ulo≈æ√≠ ho do mapy quantities spolu s odpov√≠daj√≠c√≠m textem.
                        Pokud atribut chyb√≠, metoda pokraƒçuje rekurzivnƒõ ve vno≈ôen√Ωch uzlech.</p>
                    <pre><code>
                        void trm_main::init_quantities(XMLElement *parent_elem) 
                        {
                            for (XMLElement *child = parent_elem->FirstChildElement(); child != nullptr; 
                                 child = child->NextSiblingElement()) 
                            {
                                string quantity_id = out.get_attr(child, "quantityID", false);
                                if (quantity_id == "") {
                                    init_quantities(child); // Rekurzivn√≠ vol√°n√≠ pro vno≈ôen√© uzly
                                }
                                else {
                                    string tmp_text = child->GetText();
                                    quantities[quantity_id] = out.trim_string(tmp_text); // Ulo≈æen√≠ veliƒçiny
                                }
                            }
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>
                                Proch√°z√≠ XML uzly ‚Äì metoda iteruje p≈ôes v≈°echny poduzly parent_elem.
                        Hled√° atribut quantityID ‚Äì pokud nen√≠ nalezen, pokraƒçuje do vno≈ôen√Ωch prvk≈Ø.
                        Ukl√°d√° veliƒçiny do mapy quantities ‚Äì sp√°ruje quantityID s odpov√≠daj√≠c√≠m textem.
                        Pou≈æ√≠v√° rekurzi ‚Äì umo≈æ≈àuje spr√°vnou inicializaci i pro hluboce vno≈ôen√© XML struktury.</p>
                </div>
            </div>
        
            <div class="method" id="calculate">
                <button class="method-toggle" >‚ûï calculate()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong> 
                                Tato metoda spou≈°t√≠ hlavn√≠ v√Ωpoƒçet transportn√≠ch komponent a chemick√Ωch reakc√≠.
                        Nejprve resetuje p≈ôedchoz√≠ v√Ωsledky, aktivuje transportn√≠ a reakƒçn√≠ model a pot√© iteruje p≈ôes ƒçasov√© kroky.
                        V ka≈æd√©m kroku upravuje okrajov√© podm√≠nky, poƒç√≠t√° transport a reakce a p≈ôizp≈Øsobuje ƒçasov√Ω krok
                        podle p≈ôesnosti v√Ωpoƒçt≈Ø.</p>
                    <pre><code>
                        void trm_main::calculate()
                        {
                            trans.remove_results();
                            react.remove_results();
                        
                            trans.activate();
                            vector<double> tmp_porosity = trans.get_component_data("Porosity", "", -1);
                            react.set_porosity(tmp_porosity);
                            react.set_components_for_factors(&trans.porosity, &trans.volume, &trans.conductivity_long, &trans.conductivity_trans);
                            react.init();
                            activate_boundary_conditions();
                        
                            log(BASIC) << "Calculation of time steps loop started.";
                            vector<double> transport_concs;
                            vector<string> transport_names;
                            current_bc_time = 0;
                            unsigned t_index = trans.get_time_init_id();
                            double curr_time_step = trans.get_time_step(trans.time_init_id);
                            double t;
                        
                            for (t = trans.time_init + curr_time_step; t < trans.time_end; t += curr_time_step) {
                                trans.calculate(t_index, t, transport_concs, transport_names, current_bc_time, {}, curr_time_step);
                                if (react.is_calculated_step(t_index)) {
                                    react.calculate(t_index, t, curr_time_step, transport_concs, transport_names, {});
                                }
                                t_index++;
                            }
                            log(BASIC) << "Calculation of time steps loop ended.";
                            react.close();
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Resetuje v√Ωsledky ‚Äì metoda vyma≈æe p≈ôedchoz√≠ simulace transportu a reakc√≠.
                        Inicializuje transportn√≠ a reakƒçn√≠ model ‚Äì nastavuje poƒç√°teƒçn√≠ podm√≠nky.
                        Proch√°z√≠ ƒçasov√Ωmi kroky ‚Äì iteruje p≈ôes ƒçasovou osu od poƒç√°teƒçn√≠ho do koncov√©ho ƒçasu.
                        Vypoƒç√≠t√°v√° transport ‚Äì vol√° trans.calculate(), kter√° simuluje ≈°√≠≈ôen√≠ l√°tek.
                        Vypoƒç√≠t√°v√° chemick√© reakce ‚Äì vol√° react.calculate(), kter√° poƒç√≠t√° chemick√© interakce.
                        Dynamicky upravuje ƒçasov√Ω krok ‚Äì pokud je odchylka v koncentrac√≠ch mal√°, ƒçasov√Ω krok se zvƒõt≈°√≠; pokud je velk√°, zmen≈°√≠ se.</p>
                </div>
            </div>
        
            <div class="method" id="load_inputs">
                <button class="method-toggle" >‚ûï load_inputs()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>      Metoda naƒç√≠t√° vstupn√≠ data ze souboru XML. Ovƒõ≈ôuje jeho spr√°vnost, inicializuje transportn√≠
                        a reakƒçn√≠ modul a naƒç√≠t√° jejich parametry.</p>
                    <pre><code>
                        void trm_main::load_inputs(string input_file, bool require_all_comps)
                        {
                            XMLError result = xmldoc.LoadFile(input_file.c_str());
                            if (result != tinyxml2::XML_SUCCESS) {
                                throw trm_error("Loading of input XML file failed");
                            }
                        
                            XMLElement *root_elem = xmldoc.FirstChildElement("TRM");
                            if (root_elem == nullptr) {
                                throw trm_error("No root element in input XML file");
                            }
                        
                            for (XMLElement *child = root_elem->FirstChildElement(); child != nullptr; 
                                 child = child->NextSiblingElement()) 
                            {
                                string tag_name = child->Name();
                                if (tag_name == "Quantities") {
                                    init_quantities(child);
                                } 
                                else if (tag_name == "TransportModule") {
                                    trans.set_metadata(
                                        out.get_attr(child, "name"), 
                                        out.get_attr(child, "version"), 
                                        out.get_attr(child, "type"),
                                        out.get_attr_double(child, "numTolerance", false));
                                    trans.load_time(out.get_child_elem(child, "Time"));
                                } 
                                else if (tag_name == "ReactionModule") {
                                    react.set_database(out.get_file_name_path(out.get_child_elem(child, "PhreeqcDatabase")));
                                }
                            }
                            log(BASIC) << "Input data loaded from the XML file '" + input_file + "'.";
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Naƒçte XML soubor a zkontroluje, zda se √∫spƒõ≈°nƒõ otev≈ôel.
                        Najde ko≈ôenov√Ω element XML (<TRM>) a proch√°z√≠ jeho dƒõti.
                        Inicializuje veliƒçiny (Quantities).
                        Naƒçte transportn√≠ modul ‚Äì nastav√≠ metadata, ƒçasov√© parametry a s√≠≈•.
                        Naƒçte reakƒçn√≠ modul ‚Äì nastav√≠ datab√°zi a reakƒçn√≠ parametry.</p>
                </div>
            </div>
        
            <div class="method" id="save_inputs">
                <button class="method-toggle" >‚ûï save_inputs()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>      Metoda ukl√°d√° aktu√°ln√≠ vstupn√≠ data a v√Ωsledky simulace do XML souboru.
                        Zaji≈°≈•uje konzistenci mezi ulo≈æen√Ωmi hodnotami a nastaven√≠mi modelu.</p>
                    <pre><code>
                        void trm_main::save_inputs(const string& input_file)
                        {
                            log(BASIC) << "Saving input/results file '" << input_file << "' started.";
                            XMLElement *root_elem = xmldoc.FirstChildElement("TRM");
                        
                            XMLElement *log_file_elem = out.create_element(root_elem, "LogFile", true);
                            log_file_elem->SetAttribute("filePrefix", log.get_file_prefix().c_str());
                            log_file_elem->SetAttribute("fileSuffix", log.get_file_suffix().c_str());
                        
                            trans.serialize();
                            react.serialize();
                        
                            XMLError result = xmldoc.SaveFile(input_file.c_str());
                            if (result != tinyxml2::XML_SUCCESS) {
                                throw trm_error("Saving of input XML file failed.");
                            }
                            log(BASIC) << "Saving input/results file '" << input_file << "' ended.";
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Vytvo≈ô√≠ XML dokument, pokud neexistuje.
                        Ulo≈æ√≠ nastaven√≠ logov√°n√≠.
                        Serializuje data transportu a reakc√≠ (trans.serialize(), react.serialize()).
                        Ulo≈æ√≠ do souboru pomoc√≠ xmldoc.SaveFile(input_file.c_str()).</p>
                </div>
            </div>
        </div>
    </div>
<!-- TRM_MODULE -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_module')">üìÇ trm_module.cpp</button>
    <div class="method-group-details" id="trm_module">
        
        <div class="method" id="calc_component_chars">
            <button class="method-toggle">‚ûï calc_component_chars()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Tato metoda poƒç√≠t√° minim√°ln√≠ a maxim√°ln√≠ hodnoty v≈°ech komponent v dan√© kategorii.</p>
                
                <pre><code>
void trm_module::calc_component_chars(const std::string& category) {
    vector<unsigned> times = get_component_times(category);
    vector<string> names = get_component_names(category);
    for (auto& name : names) {
        double tmp_min = numeric_limits<double>::max();
        double tmp_max = numeric_limits<double>::lowest();
        for (auto time : times) {
            arma::mat data = get_component_data(category, name, time);
            double data_min = data.min();
            double data_max = data.max();
            if (data_min < tmp_min) {
                tmp_min = data.min();
            }
            if (data_max > tmp_max) {
                tmp_max = data.max();
            }
        }
        set_component_char(category, name, "min", tmp_min);
        set_component_char(category, name, "max", tmp_max);
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Pro ka≈ædou komponentu v kategorii projde dostupn√° ƒçasov√° data, spoƒç√≠t√° minimum a maximum a tyto hodnoty ulo≈æ√≠.</p>
            </div>
        </div>

        <div class="method" id="load_time">
            <button class="method-toggle">‚ûï load_time()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Naƒçte nastaven√≠ ƒçasu z XML souboru a inicializuje ƒçasov√© kroky.</p>
                
                <pre><code>
void trm_module::load_time(XMLElement *time_elem) {
    set_time(
        output->get_attr_unsigned(time_elem, "quantityID"), 
        output->get_child_elem_double(time_elem, "Init"), 
        output->get_child_elem_double(time_elem, "End"));

    XMLElement *step_zero_elem = output->get_child_elem(time_elem, "Step");
    unsigned zero_time_id = (output->get_attr(step_zero_elem, "idTimeStep", false) == "") ? 
                             0 : output->get_attr_unsigned(step_zero_elem, "idTimeStep");

    bc_times_steps.clear();
    bc_times_steps[zero_time_id] = output->get_elem_double(step_zero_elem);

    XMLElement *bc_changes_elem = output->get_child_elem(time_elem, "BorderCondChanges", false);
    if (bc_changes_elem != nullptr) {
        vector<XMLElement*> bc_step_elems = output->get_child_elems(bc_changes_elem, "Step", false);
        for (auto step_elem : bc_step_elems) {
            unsigned curr_bc_time = output->get_attr_unsigned(step_elem, "idTimeStep");
            bc_times_steps[curr_bc_time] = output->get_elem_double(step_elem);
        }
    }
    check_bc_change_times();
    set_time_init_id();
    set_time_end_id();
}
                </code></pre>
                <p><strong>Jak funguje:</strong> ƒåte z XML elementy `Step` a `BorderCondChanges`, nastavuje ƒçasy a kroky zmƒõn okrajov√Ωch podm√≠nek.</p>
            </div>
        </div>
        
    </div>
</div>
    
<!-- TRM_REACT -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_react')">üìÇ trm_react.cpp</button>
    <div class="method-group-details" id="trm_react">

        <div class="method" id="activate_boundary_conditions">
            <button class="method-toggle">‚ûï activate_boundary_conditions()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Aktivuje okrajov√© podm√≠nky pro reakƒçn√≠ modul a vypoƒç√≠t√° jejich koncentrace.</p>
                <pre><code>
void reaction_module::activate_boundary_conditions(
    vector<string>& component_names, vector_values& bound_cond_vec,
    map<unsigned, vector<double>>& boundary_concs, unsigned bc_time) {

    if (has_state(DISABLED)) return;

    try {
        log(BASIC) << "Activation of boundary conditions by the reaction module started.";

        for (auto& bcond : boundary_conditions) {
            phreeq->RunString(false, true, false, "DELETE; -all");
            phreeq->RunFile(false, true, false, bcond.second);

            istringstream iss(bcond.first);
            double bound_id;
            iss >> bound_id;

            vector<unsigned> indexes_for_bound = bound_cond_vec.find_which_equals(bound_id);
            vector<int> indexes_for_bound_int(indexes_for_bound.begin(), indexes_for_bound.end());

            if (!indexes_for_bound.empty()) {
                vector<double> boundary_concentrations;
                vector<int> boundary_cond(1, -1);
                phreeq->InitialPhreeqc2Concentrations(boundary_concentrations, boundary_cond);
                phreeq->RunString(false, true, false, "DELETE; -all");

                for (auto& index : indexes_for_bound_int) {
                    boundary_concs[index] = boundary_concentrations;
                }
                log(BASIC) << "Boundary conditions set from file '" << bcond.second << "' for time " << bc_time << ".";
            }
        }
        component_names = phreeq->GetComponents();
        log(BASIC) << "Activation of boundary conditions by the reaction module ended.";
    }
    catch (PhreeqcRMStop& stop) {
        throw trm_error("PhreeqcRM error:\n" + phreeq->GetErrorString() + "Activation of the reaction module failed.");
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Naƒç√≠t√° soubory s okrajov√Ωmi podm√≠nkami, p≈ôid√°v√° odpov√≠daj√≠c√≠ koncentrace pro bu≈àky a p≈ôed√°v√° je do Phreeqc.</p>

            </div>
        </div>

        <div class="method" id="activate">
            <button class="method-toggle">‚ûï activate()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Aktivuje reakƒçn√≠ modul pro dan√© bu≈àky a inicializuje poƒç√°teƒçn√≠ podm√≠nky.</p>
                
                <pre><code>
void reaction_module::activate(
    vector<double>& concentrations, vector<string>& component_names, vector_values& init_cond_vec,
    arma::mat in_component_data, unsigned bc_time, double time, component &mapping_component) {

    if (has_state(DISABLED)) return;

    try {
        log(BASIC) << "Activation of the reaction module started.";

        if (bc_time == 0) {
            clustering_coeffs.clear();
            double curr_coeff = mapping_component.get_clustering_coeff();
            if (!isnan(curr_coeff)) {
                clustering_coeffs["mapping"] = curr_coeff;
            }

            for (auto& comp_for_factors : components_for_factors) {
                curr_coeff = comp_for_factors.second->get_clustering_coeff();
                if (!isnan(curr_coeff)) {
                    clustering_coeffs[comp_for_factors.first] = curr_coeff;
                }
            }

            phreeq->RunString(true, true, true, "DELETE; -all");
            for (auto& icond : initial_conditions) {
                phreeq->RunFile(false, true, false, icond.second);

                istringstream iss(icond.first);
                double cond_id;
                iss >> cond_id;
                vector<unsigned> indexes_for_cond = init_cond_vec.find_which_equals(cond_id);
                vector<int> indexes_for_cond_int(indexes_for_cond.begin(), indexes_for_cond.end());

                if (!indexes_for_cond.empty()) {
                    phreeq->InitialPhreeqcCell2Module(-1, indexes_for_cond_int);
                    log(BASIC) << "Initial conditions set from file '" + icond.second + "'.";
                }
                phreeq->RunString(false, true, false, "DELETE; -all");
            }

            phreeq->SetTime(0.0);
            phreeq->SetTimeStep(0.0);
            phreeq->RunCells();

            component_names = phreeq->GetComponents();
            phreeq->GetConcentrations(concentrations);

            log(BASIC) << "Activation of the reaction module ended.";
        }
    }
    catch (PhreeqcRMStop& stop) {
        throw trm_error("PhreeqcRM error:\n" + phreeq->GetErrorString() + "Activation of the reaction module failed.");
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Naƒç√≠t√° poƒç√°teƒçn√≠ podm√≠nky, nastavuje faktory pro v√Ωpoƒçty a spou≈°t√≠ Phreeqc.</p>
            </div>
        </div>

        <div class="method" id="react_calculate">
            <button class="method-toggle">‚ûï calculate()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Vypoƒç√≠t√°v√° reakƒçn√≠ modul pro dan√Ω ƒçasov√Ω krok.</p>
                
                <pre><code>
void reaction_module::calculate(
    unsigned t_index, double time, double time_step, vector<double>& concentrations, 
    vector<string>& names, vector<double>& mapping) {

    if (has_state(DISABLED) || has_state(DISABLED_CALCULATION)) return;

    try {
        set_factors(false, mapping, concentrations, names);

        ostringstream oss;
        oss << t_index;
        string t_index_str = oss.str();
        set_properties(t_index_str);

        phreeq->SetPrintChemistryOn(sett.get_bool("writeOutput") && output_phreeq->is_step_for_output(t_index, time_end_id), false, false);
        phreeq->SetSelectedOutputOn(output->is_step_for_output(t_index, time_end_id) || !clustering_coeffs.empty());

        if (!clustering_coeffs.empty()) {
            set_mapping();
        }

        phreeq->SetConcentrations(concentrations);
        phreeq->SetTimeStep(time_step);
        phreeq->SetTime(time);
        phreeq->RunCells();
        phreeq->GetConcentrations(concentrations);

        if (output->is_step_for_output(t_index, time_end_id)) {
            store_results(t_index, time, concentrations, names);
        }
        if (output_observation->is_step_for_output(t_index, time_end_id)) {
            save_observations(t_index);
        }
    }
    catch (PhreeqcRMStop& stop) {
        throw trm_error("PhreeqcRM error:\n" + phreeq->GetErrorString() + 
        "Calculation of the reaction module failed in time step '" << t_index << "' (time " << time << ").");
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Phreeqc prov√°d√≠ v√Ωpoƒçty na z√°kladƒõ koncentrac√≠ a okrajov√Ωch podm√≠nek.</p>
            </div>
        </div>

    </div>
</div>

        <!-- TRM_TRANS -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_trans')">üìÇ trm_trans.cpp</button>
    <div class="method-group-details" id="trm_trans">

        <div class="method" id="init_grid_flow">
            <button class="method-toggle">‚ûï init_grid_flow()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Inicializuje matice tok≈Ø v gridu.</p>
                
                <pre><code>
void transport_module::init_grid_flow(unsigned bc_time) {
    if (grid_flow.find(bc_time) == grid_flow.end()) {
        component tmp_component;
        tmp_component.set_metadata("", "", "sparseMatrix", "double", "4");
        grid_flow[bc_time] = tmp_component;
    }

    arma::sp_mat tmp_grid_flow = grid_flow[bc_time].get_data_sparse();
    if (tmp_grid_flow.n_elem != get_cell_count("GridFlow")) {
        check_conductivity();
        if (position1.n_elem == 0) {
            calc_positions(ncells);
        }
        if (hydraulic_head[bc_time].get_data().n_elem == 0) {
            init_hydraulic_head(bc_time);
        }
        tmp_grid_flow.set_size(ncells, ncells);
        tmp_grid_flow.zeros();

        arma::sp_mat head_as_sp = arma::conv_to<arma::sp_mat>::from(hydraulic_head[bc_time].get_data());
        arma::sp_mat flow1 = position1 * head_as_sp;
        arma::sp_mat flow2 = position2 * head_as_sp;
        arma::sp_mat flow3 = position3 * head_as_sp;
        arma::sp_mat flow4 = position4 * head_as_sp;

        for (unsigned i = 0; i < ncells; i++) {
            for (unsigned j = 0; j < ncells; j++) {
                if (j == i - ncols && i > ncols - 1) {
                    tmp_grid_flow(i, j) += -flow3(j + ncols, 0);
                }
                if (j == i - 1 && i % ncols > 0) {
                    tmp_grid_flow(i, j) += -flow1(j + 1, 0);
                }
                if (j == i + 1 && j % ncols > 0) {
                    tmp_grid_flow(i, j) += -flow2(j - 1, 0);
                }
                if (j == i + ncols) {
                    tmp_grid_flow(i, j) += -flow4(j - ncols, 0);
                }
            }
        }
        grid_flow[bc_time].set_data_sparse(tmp_grid_flow, false, true);
        log(BASIC) << "Grid flow initialized for BC time " << bc_time;
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Vytvo≈ô√≠ sparse matici pro `grid_flow`, pokud je≈°tƒõ nen√≠ definov√°na, a n√°slednƒõ napln√≠ hodnotami na z√°kladƒõ hydraulick√© hlavy.</p>
            </div>
        </div>

        <div class="method" id="trans_calculate">
            <button class="method-toggle">‚ûï calculate()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Hlavn√≠ v√Ωpoƒçet transportn√≠ch komponent.</p>
                
                <pre><code>
void transport_module::calculate(unsigned t_index, double time, vector<double>& concentrations, 
    vector<string>& component_names, unsigned curr_bc_time, vector<double>& mapping, double curr_time_step) {

    if (has_state(DISABLED) || has_state(DISABLED_CALCULATION)) return;

    transport_components_mat += volume_diag_inverse * (in_out_flow_modif * in_comps * curr_time_step + 
        grid_flow_modif * transport_components_mat * curr_time_step + 
        diff_flows_mat * transport_components_mat * diff_coeffs_mat * curr_time_step + 
        in_out_diff_mat * in_comps * diff_coeffs_mat * curr_time_step);

    mapping = arma::conv_to<vector<double>>::from(transport_components_mat.col(0));

    log(BASIC) << "Transport for time step ID '" << t_index << "' (time " << time << ") calculated.";
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Prob√≠h√° v√Ωpoƒçet tok≈Ø a koncentrac√≠ pomoc√≠ diferenci√°ln√≠ch rovnic a maticov√Ωch operac√≠.</p>
            </div>
        </div>
    </div>
</div>
    
        <!-- TRM_INOUT -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_inout')">üìÇ trm_inout.cpp</button>
    <div class="method-group-details" id="trm_inout">

        <div class="method" id="load_output_settings">
            <button class="method-toggle">‚ûï load_output_settings()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Naƒç√≠t√° nastaven√≠ v√Ωstupn√≠ch soubor≈Ø z XML souboru.</p>
                <pre><code>
void outputter::load_output_settings(XMLElement *result_file_elem, const string& tag_name)
{
    XMLElement *output_elem = get_child_elem(result_file_elem, tag_name);
    string filename = get_attr(result_file_elem, "filename");
    type = tag_name;
    string use_observation_str = get_attr(result_file_elem, "useObservation", false);
    bool use_observation = use_observation_str.empty() ? false : get_attr_boolean(result_file_elem, "useObservation", true);

    set_values(get_attr(output_elem, "writeCells"), get_attr(output_elem, "writeSteps"), 
        get_attr(result_file_elem, "directoryPath"), get_attr_boolean(result_file_elem, "useCsvSubdirs", false), 
        use_observation, trim_string(filename));

    set_cell_ids(get_attrs_from_children_unsigned(output_elem, "WriteCell", "id"));
    set_step_ids(get_attrs_from_children_unsigned(output_elem, "WriteStep", "id"));

    if (get_child_elem(output_elem, "LoopStep", false) != nullptr) {
        loop_step = get_child_elem_unsigned(output_elem, "LoopStep");
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Extrahuje cesty, typy v√Ωstupn√≠ch soubor≈Ø a dal≈°√≠ nastaven√≠ z XML uzlu a ukl√°d√° je do objektu `outputter`.</p>

            </div>
        </div>

        <div class="method" id="set_values">
            <button class="method-toggle">‚ûï set_values()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Nastavuje vlastnosti v√Ωstupn√≠ch soubor≈Ø, jako jsou adres√°≈ôe, typy v√Ωstup≈Ø a form√°ty soubor≈Ø.</p>
                <pre><code>
void outputter::set_values(const string& cell_output_type, const string& step_output_type, 
    const string& directory, bool use_csv_subdirs, bool use_observation, const string& file_name)
{
    vector<string> tmp_types { "none", "all" };
    if (!is_transport()) {
        tmp_types.push_back("list");
    }
    if (find(tmp_types.begin(), tmp_types.end(), cell_output_type) == tmp_types.end()) {
        throw trm_error("Invalid cell output type '" + cell_output_type + "'.");
    }
    this->cell_output_type = cell_output_type;

    tmp_types.push_back("list");
    tmp_types.push_back("last");
    if (find(tmp_types.begin(), tmp_types.end(), step_output_type) == tmp_types.end()) {
        throw trm_error("Invalid step output type '" + step_output_type + "'.");
    }
    this->step_output_type = step_output_type;

    this->use_csv_subdirs = use_csv_subdirs;
    this->use_observation = use_observation;
    set_dir_file(directory, file_name);
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Kontroluje, zda jsou zadan√© typy platn√©, a nastavuje odpov√≠daj√≠c√≠ vlastnosti pro ukl√°d√°n√≠ v√Ωstup≈Ø.</p>

            </div>
        </div>

        <div class="method" id="mat_to_csv">
            <button class="method-toggle">‚ûï mat_to_csv()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Ukl√°d√° matici dat do CSV souboru.</p>
                <pre><code>
void outputter::mat_to_csv(arma::mat mat, string file_name, bool adapt_size, unsigned nrows, unsigned ncols)
{
    arma::mat export_mat(mat);
    if (cell_output_type == "list") {
        export_mat.resize(0, 0);
        for (auto row_id : cell_ids) {
            if (row_id > mat.n_rows) {
                throw trm_error("Cell index for results is out of data range.");
            }
            export_mat = join_cols(export_mat, mat.row(row_id - 1)); // cell_ids jsou indexov√°ny od 1
        }
    }
    else if (adapt_size) {
        if (nrows * ncols != mat.n_elem) {
            throw trm_error("Number of matrix elements does not fit to the given size.");
        }
        export_mat.resize(nrows, ncols);
        unsigned i = 0;
        for (unsigned r = 0; r < nrows; r++) {
            for (unsigned c = 0; c < ncols; c++) {
                export_mat(r, c) = mat(i, 0);
                i++;
            }
        }
    }
    export_mat.save(file_name, arma::csv_ascii);
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Zaji≈°≈•uje spr√°vn√© form√°tov√°n√≠ matice, p≈ô√≠padnƒõ ji p≈ôizp≈Øsobuje po≈æadovan√© velikosti, a pot√© ji ukl√°d√° do souboru.</p>

            </div>
        </div>

    </div>
</div>

    </section>
        

    </main>


    <footer>
        <p>&copy; 2025 TRM 2D</p>
        <p><a target="_blank" href="https://achecks.org/achecker#wcag21aa-desktop,https://mivoru.github.io/TWS_SP_Votypka/implementation.html"><img src="https://achecks.org/images/icon_W21_aa.png" alt="AChecker accessibility checker: WCAG 2.1 (Level AA)" height="32" width="88" /></a>
        </p>
    </footer>
</body>
</html>
