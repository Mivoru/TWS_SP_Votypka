<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementace TRM 2D</title>
    <link rel="stylesheet" href="style.css">
    <script src="script.js" defer></script>
</head>
<body>
    <header>
        <h1>Implementace TRM 2D</h1>
        <div class="settings-container">
            <div id="settingsIcon"></div> 
            <div class="settings-buttons hidden">
                <button id="toggle-layout">P≈ôepnout rozlo≈æen√≠</button>
                <button id="dark-mode-toggle">Tmav√Ω re≈æim</button>
                <button id="alt-mode-toggle">Alternativn√≠ re≈æim</button>
            </div>
        </div>
        <button class="menu-toggle">‚ò∞</button>
        <nav>
            <ul>
                <li><a href="index.html">√övod</a></li>
                <li><a href="transport.html">Transportn√≠ model</a></li>
                <li><a href="reaction.html">Reakƒçn√≠ model</a></li>
                <li><a href="contact.html">Kontakt</a></li>
                <li><a href="methods.html">Metody</a></li>
            </ul>
        </nav>
    </header>
    

    <main>
        <section id="implementation">
            <h2>P≈ôehled implementace</h2>
            <p>TRM 2D je implementov√°n jako konzolov√° aplikace, kter√° vyu≈æ√≠v√°:</p>
            <ul>
                <li>Metodu koneƒçn√Ωch diferenc√≠ (FDM) pro transport.</li>
                <li>Metodu koneƒçn√Ωch objem≈Ø (FVM) pro reakce.</li>
                <li>Automatick√© ≈ô√≠zen√≠ ƒçasov√©ho kroku pro zaji≈°tƒõn√≠ stability v√Ωpoƒçt≈Ø.</li>
            </ul>
        </section>

        <section id="method-list">
            <h2>Seznam metod</h2>
        
            <!-- TRM -->
            <div class="method-group">
                <button class="group-toggle" onclick="toggleGroup('trm')">üìÇ trm.h</button>
                <div class="method-group-details" id="trm">
            <div class="method" id="init_quantities">
                <button class="method-toggle">‚ûï init_quantities()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>
                                Tato metoda inicializuje seznam veliƒçin a jejich jednotek na z√°kladƒõ XML souboru.
                        Proch√°z√≠ XML stromem a hled√° uzly s atributem quantityID. Pokud je atribut nalezen,
                        ulo≈æ√≠ ho do mapy quantities spolu s odpov√≠daj√≠c√≠m textem.
                        Pokud atribut chyb√≠, metoda pokraƒçuje rekurzivnƒõ ve vno≈ôen√Ωch uzlech.</p>
                    <pre><code>
                        void trm_main::init_quantities(XMLElement *parent_elem) 
                        {
                            for (XMLElement *child = parent_elem->FirstChildElement(); child != nullptr; 
                                 child = child->NextSiblingElement()) 
                            {
                                string quantity_id = out.get_attr(child, "quantityID", false);
                                if (quantity_id == "") {
                                    init_quantities(child); // Rekurzivn√≠ vol√°n√≠ pro vno≈ôen√© uzly
                                }
                                else {
                                    string tmp_text = child->GetText();
                                    quantities[quantity_id] = out.trim_string(tmp_text); // Ulo≈æen√≠ veliƒçiny
                                }
                            }
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>
                                Proch√°z√≠ XML uzly ‚Äì metoda iteruje p≈ôes v≈°echny poduzly parent_elem.
                        Hled√° atribut quantityID ‚Äì pokud nen√≠ nalezen, pokraƒçuje do vno≈ôen√Ωch prvk≈Ø.
                        Ukl√°d√° veliƒçiny do mapy quantities ‚Äì sp√°ruje quantityID s odpov√≠daj√≠c√≠m textem.
                        Pou≈æ√≠v√° rekurzi ‚Äì umo≈æ≈àuje spr√°vnou inicializaci i pro hluboce vno≈ôen√© XML struktury.</p>
                </div>
            </div>
        
            <div class="method" id="calculate">
                <button class="method-toggle" >‚ûï calculate()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong> 
                                Tato metoda spou≈°t√≠ hlavn√≠ v√Ωpoƒçet transportn√≠ch komponent a chemick√Ωch reakc√≠.
                        Nejprve resetuje p≈ôedchoz√≠ v√Ωsledky, aktivuje transportn√≠ a reakƒçn√≠ model a pot√© iteruje p≈ôes ƒçasov√© kroky.
                        V ka≈æd√©m kroku upravuje okrajov√© podm√≠nky, poƒç√≠t√° transport a reakce a p≈ôizp≈Øsobuje ƒçasov√Ω krok
                        podle p≈ôesnosti v√Ωpoƒçt≈Ø.</p>
                    <pre><code>
                        void trm_main::calculate()
                        {
                            trans.remove_results();
                            react.remove_results();
                        
                            trans.activate();
                            vector<double> tmp_porosity = trans.get_component_data("Porosity", "", -1);
                            react.set_porosity(tmp_porosity);
                            react.set_components_for_factors(&trans.porosity, &trans.volume, &trans.conductivity_long, &trans.conductivity_trans);
                            react.init();
                            activate_boundary_conditions();
                        
                            log(BASIC) << "Calculation of time steps loop started.";
                            vector<double> transport_concs;
                            vector<string> transport_names;
                            current_bc_time = 0;
                            unsigned t_index = trans.get_time_init_id();
                            double curr_time_step = trans.get_time_step(trans.time_init_id);
                            double t;
                        
                            for (t = trans.time_init + curr_time_step; t < trans.time_end; t += curr_time_step) {
                                trans.calculate(t_index, t, transport_concs, transport_names, current_bc_time, {}, curr_time_step);
                                if (react.is_calculated_step(t_index)) {
                                    react.calculate(t_index, t, curr_time_step, transport_concs, transport_names, {});
                                }
                                t_index++;
                            }
                            log(BASIC) << "Calculation of time steps loop ended.";
                            react.close();
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Resetuje v√Ωsledky ‚Äì metoda vyma≈æe p≈ôedchoz√≠ simulace transportu a reakc√≠.
                        Inicializuje transportn√≠ a reakƒçn√≠ model ‚Äì nastavuje poƒç√°teƒçn√≠ podm√≠nky.
                        Proch√°z√≠ ƒçasov√Ωmi kroky ‚Äì iteruje p≈ôes ƒçasovou osu od poƒç√°teƒçn√≠ho do koncov√©ho ƒçasu.
                        Vypoƒç√≠t√°v√° transport ‚Äì vol√° trans.calculate(), kter√° simuluje ≈°√≠≈ôen√≠ l√°tek.
                        Vypoƒç√≠t√°v√° chemick√© reakce ‚Äì vol√° react.calculate(), kter√° poƒç√≠t√° chemick√© interakce.
                        Dynamicky upravuje ƒçasov√Ω krok ‚Äì pokud je odchylka v koncentrac√≠ch mal√°, ƒçasov√Ω krok se zvƒõt≈°√≠; pokud je velk√°, zmen≈°√≠ se.</p>
                </div>
            </div>
        
            <div class="method" id="load_inputs">
                <button class="method-toggle" >‚ûï load_inputs()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>      Metoda naƒç√≠t√° vstupn√≠ data ze souboru XML. Ovƒõ≈ôuje jeho spr√°vnost, inicializuje transportn√≠
                        a reakƒçn√≠ modul a naƒç√≠t√° jejich parametry.</p>
                    <pre><code>
                        void trm_main::load_inputs(string input_file, bool require_all_comps)
                        {
                            XMLError result = xmldoc.LoadFile(input_file.c_str());
                            if (result != tinyxml2::XML_SUCCESS) {
                                throw trm_error("Loading of input XML file failed");
                            }
                        
                            XMLElement *root_elem = xmldoc.FirstChildElement("TRM");
                            if (root_elem == nullptr) {
                                throw trm_error("No root element in input XML file");
                            }
                        
                            for (XMLElement *child = root_elem->FirstChildElement(); child != nullptr; 
                                 child = child->NextSiblingElement()) 
                            {
                                string tag_name = child->Name();
                                if (tag_name == "Quantities") {
                                    init_quantities(child);
                                } 
                                else if (tag_name == "TransportModule") {
                                    trans.set_metadata(
                                        out.get_attr(child, "name"), 
                                        out.get_attr(child, "version"), 
                                        out.get_attr(child, "type"),
                                        out.get_attr_double(child, "numTolerance", false));
                                    trans.load_time(out.get_child_elem(child, "Time"));
                                } 
                                else if (tag_name == "ReactionModule") {
                                    react.set_database(out.get_file_name_path(out.get_child_elem(child, "PhreeqcDatabase")));
                                }
                            }
                            log(BASIC) << "Input data loaded from the XML file '" + input_file + "'.";
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Naƒçte XML soubor a zkontroluje, zda se √∫spƒõ≈°nƒõ otev≈ôel.
                        Najde ko≈ôenov√Ω element XML (<TRM>) a proch√°z√≠ jeho dƒõti.
                        Inicializuje veliƒçiny (Quantities).
                        Naƒçte transportn√≠ modul ‚Äì nastav√≠ metadata, ƒçasov√© parametry a s√≠≈•.
                        Naƒçte reakƒçn√≠ modul ‚Äì nastav√≠ datab√°zi a reakƒçn√≠ parametry.</p>
                </div>
            </div>
        
            <div class="method" id="save_inputs">
                <button class="method-toggle" >‚ûï save_inputs()</button>
                <div class="method-details">
                    <p><strong>Popis:</strong>      Metoda ukl√°d√° aktu√°ln√≠ vstupn√≠ data a v√Ωsledky simulace do XML souboru.
                        Zaji≈°≈•uje konzistenci mezi ulo≈æen√Ωmi hodnotami a nastaven√≠mi modelu.</p>
                    <pre><code>
                        void trm_main::save_inputs(const string& input_file)
                        {
                            log(BASIC) << "Saving input/results file '" << input_file << "' started.";
                            XMLElement *root_elem = xmldoc.FirstChildElement("TRM");
                        
                            XMLElement *log_file_elem = out.create_element(root_elem, "LogFile", true);
                            log_file_elem->SetAttribute("filePrefix", log.get_file_prefix().c_str());
                            log_file_elem->SetAttribute("fileSuffix", log.get_file_suffix().c_str());
                        
                            trans.serialize();
                            react.serialize();
                        
                            XMLError result = xmldoc.SaveFile(input_file.c_str());
                            if (result != tinyxml2::XML_SUCCESS) {
                                throw trm_error("Saving of input XML file failed.");
                            }
                            log(BASIC) << "Saving input/results file '" << input_file << "' ended.";
                        }
                        
                    </code></pre>
                    <p><strong>Jak to funguje?</strong>     Vytvo≈ô√≠ XML dokument, pokud neexistuje.
                        Ulo≈æ√≠ nastaven√≠ logov√°n√≠.
                        Serializuje data transportu a reakc√≠ (trans.serialize(), react.serialize()).
                        Ulo≈æ√≠ do souboru pomoc√≠ xmldoc.SaveFile(input_file.c_str()).</p>
                </div>
            </div>
        </div>
    </div>
<!-- TRM_MODULE -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_module')">üìÇ trm_module.h</button>
    <div class="method-group-details" id="trm_module">
        
        <div class="method" id="calc_component_chars">
            <button class="method-toggle">calc_component_chars()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Tato metoda poƒç√≠t√° minim√°ln√≠ a maxim√°ln√≠ hodnoty v≈°ech komponent v dan√© kategorii.</p>
                
                <pre><code>
void trm_module::calc_component_chars(const std::string& category) {
    vector<unsigned> times = get_component_times(category);
    vector<string> names = get_component_names(category);
    for (auto& name : names) {
        double tmp_min = numeric_limits<double>::max();
        double tmp_max = numeric_limits<double>::lowest();
        for (auto time : times) {
            arma::mat data = get_component_data(category, name, time);
            double data_min = data.min();
            double data_max = data.max();
            if (data_min < tmp_min) {
                tmp_min = data.min();
            }
            if (data_max > tmp_max) {
                tmp_max = data.max();
            }
        }
        set_component_char(category, name, "min", tmp_min);
        set_component_char(category, name, "max", tmp_max);
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Pro ka≈ædou komponentu v kategorii projde dostupn√° ƒçasov√° data, spoƒç√≠t√° minimum a maximum a tyto hodnoty ulo≈æ√≠.</p>
            </div>
        </div>

        <div class="method" id="load_time">
            <button class="method-toggle">load_time()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Naƒçte nastaven√≠ ƒçasu z XML souboru a inicializuje ƒçasov√© kroky.</p>
                
                <pre><code>
void trm_module::load_time(XMLElement *time_elem) {
    set_time(
        output->get_attr_unsigned(time_elem, "quantityID"), 
        output->get_child_elem_double(time_elem, "Init"), 
        output->get_child_elem_double(time_elem, "End"));

    XMLElement *step_zero_elem = output->get_child_elem(time_elem, "Step");
    unsigned zero_time_id = (output->get_attr(step_zero_elem, "idTimeStep", false) == "") ? 
                             0 : output->get_attr_unsigned(step_zero_elem, "idTimeStep");

    bc_times_steps.clear();
    bc_times_steps[zero_time_id] = output->get_elem_double(step_zero_elem);

    XMLElement *bc_changes_elem = output->get_child_elem(time_elem, "BorderCondChanges", false);
    if (bc_changes_elem != nullptr) {
        vector<XMLElement*> bc_step_elems = output->get_child_elems(bc_changes_elem, "Step", false);
        for (auto step_elem : bc_step_elems) {
            unsigned curr_bc_time = output->get_attr_unsigned(step_elem, "idTimeStep");
            bc_times_steps[curr_bc_time] = output->get_elem_double(step_elem);
        }
    }
    check_bc_change_times();
    set_time_init_id();
    set_time_end_id();
}
                </code></pre>
                <p><strong>Jak funguje:</strong> ƒåte z XML elementy `Step` a `BorderCondChanges`, nastavuje ƒçasy a kroky zmƒõn okrajov√Ωch podm√≠nek.</p>
            </div>
        </div>
        
    </div>
</div>
    
        <!-- TRM_REACT -->
        <div class="method-group">
            <button class="group-toggle" onclick="toggleGroup('trm_react')">üìÇ trm_react.h</button>
            <div class="method-group-details" id="trm_react">
                <div class="method" id="activate">
                    <button class="method-toggle">activate()</button>
                    <div class="method-details">
                        <p><strong>Popis:</strong> Aktivuje poƒç√°teƒçn√≠ podm√≠nky pro reakce.</p>
                        <pre><code>
    void reaction_module::activate(...) {
        log(BASIC) << "Reaction module activated.";
    }
                        </code></pre>
                    </div>
                </div>
            </div>
        </div>
    
        <!-- TRM_TRANS -->
<div class="method-group">
    <button class="group-toggle" onclick="toggleGroup('trm_trans')">üìÇ trm_trans.h</button>
    <div class="method-group-details" id="trm_trans">

        <div class="method" id="init_grid_flow">
            <button class="method-toggle">init_grid_flow()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Inicializuje matice tok≈Ø v gridu.</p>
                
                <pre><code>
void transport_module::init_grid_flow(unsigned bc_time) {
    if (grid_flow.find(bc_time) == grid_flow.end()) {
        component tmp_component;
        tmp_component.set_metadata("", "", "sparseMatrix", "double", "4");
        grid_flow[bc_time] = tmp_component;
    }

    arma::sp_mat tmp_grid_flow = grid_flow[bc_time].get_data_sparse();
    if (tmp_grid_flow.n_elem != get_cell_count("GridFlow")) {
        check_conductivity();
        if (position1.n_elem == 0) {
            calc_positions(ncells);
        }
        if (hydraulic_head[bc_time].get_data().n_elem == 0) {
            init_hydraulic_head(bc_time);
        }
        tmp_grid_flow.set_size(ncells, ncells);
        tmp_grid_flow.zeros();

        arma::sp_mat head_as_sp = arma::conv_to<arma::sp_mat>::from(hydraulic_head[bc_time].get_data());
        arma::sp_mat flow1 = position1 * head_as_sp;
        arma::sp_mat flow2 = position2 * head_as_sp;
        arma::sp_mat flow3 = position3 * head_as_sp;
        arma::sp_mat flow4 = position4 * head_as_sp;

        for (unsigned i = 0; i < ncells; i++) {
            for (unsigned j = 0; j < ncells; j++) {
                if (j == i - ncols && i > ncols - 1) {
                    tmp_grid_flow(i, j) += -flow3(j + ncols, 0);
                }
                if (j == i - 1 && i % ncols > 0) {
                    tmp_grid_flow(i, j) += -flow1(j + 1, 0);
                }
                if (j == i + 1 && j % ncols > 0) {
                    tmp_grid_flow(i, j) += -flow2(j - 1, 0);
                }
                if (j == i + ncols) {
                    tmp_grid_flow(i, j) += -flow4(j - ncols, 0);
                }
            }
        }
        grid_flow[bc_time].set_data_sparse(tmp_grid_flow, false, true);
        log(BASIC) << "Grid flow initialized for BC time " << bc_time;
    }
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Vytvo≈ô√≠ sparse matici pro `grid_flow`, pokud je≈°tƒõ nen√≠ definov√°na, a n√°slednƒõ napln√≠ hodnotami na z√°kladƒõ hydraulick√© hlavy.</p>
            </div>
        </div>

        <div class="method" id="calculate">
            <button class="method-toggle">calculate()</button>
            <div class="method-details">
                <p><strong>Popis:</strong> Hlavn√≠ v√Ωpoƒçet transportn√≠ch komponent.</p>
                
                <pre><code>
void transport_module::calculate(unsigned t_index, double time, vector<double>& concentrations, 
    vector<string>& component_names, unsigned curr_bc_time, vector<double>& mapping, double curr_time_step) {

    if (has_state(DISABLED) || has_state(DISABLED_CALCULATION)) return;

    transport_components_mat += volume_diag_inverse * (in_out_flow_modif * in_comps * curr_time_step + 
        grid_flow_modif * transport_components_mat * curr_time_step + 
        diff_flows_mat * transport_components_mat * diff_coeffs_mat * curr_time_step + 
        in_out_diff_mat * in_comps * diff_coeffs_mat * curr_time_step);

    mapping = arma::conv_to<vector<double>>::from(transport_components_mat.col(0));

    log(BASIC) << "Transport for time step ID '" << t_index << "' (time " << time << ") calculated.";
}
                </code></pre>
                <p><strong>Jak funguje:</strong> Prob√≠h√° v√Ωpoƒçet tok≈Ø a koncentrac√≠ pomoc√≠ diferenci√°ln√≠ch rovnic a maticov√Ωch operac√≠.</p>
            </div>
        </div>
    </div>
</div>
    
        <!-- TRM_INOUT -->
        <div class="method-group">
            <button class="group-toggle" onclick="toggleGroup('trm_inout')">üìÇ trm_inout.h</button>
            <div class="method-group-details" id="trm_inout">
                <div class="method" id="serialize">
                    <button class="method-toggle">serialize()</button>
                    <div class="method-details">
                        <p><strong>Popis:</strong> Ukl√°d√° data do XML souboru.</p>
                        <pre><code>
    void outputter::serialize(...) {
        log(BASIC) << "Saving results to XML.";
    }
                        </code></pre>
                    </div>
                </div>
            </div>
        </div>
    </section>
        

    </main>


    <footer>
        <p>&copy; 2025 TRM 2D</p>
        <p><a href="https://validator.w3.org/">Validace HTML</a></p>
    </footer>
</body>
</html>
